# https://chatgpt.com/c/683a8cde-4a10-8000-97a9-dc69a2a10e84

cluster:
  name: "kube-prod-d1"

global:
  scrapeInterval: 60s
  maxCacheSize: 100000

destinations:
  - name: localMetrics
    type: prometheus
    url: http://mimir-distributor.mimir.svc.cluster.local:8080/api/v1/push
    extraHeaders: 
      X-Scope-OrgID: anonymous
  - name: localLogs
    type: loki
    url: "http://loki-distributor.loki.svc.cluster.local:3100/loki/api/v1/push"
    tenantId: anonymous
  - name: otlpLocal
    type: otlp
    protocol: grpc
    tenantId: anonymous
    tls:
      insecure: true
    url: "http://tempo-distributor.tempo.svc.cluster.local:4317"
    metrics: { enabled: true }
    logs: { enabled: true }
    traces: { enabled: true }
  # - name: pyroscope
  #   type: pyroscope
  #   url: http://pyroscope.pyroscope.svc:4040

clusterMetrics:
  
  enabled: true
  
  controlPlane:
    enabled: true
  
  kubelet:
    enabled: false

  kubeletProbes:
    enabled: false
  
  kubeletResource:
    enabled: false
  
  cadvisor:
    enabled: true

    # extraMetricProcessingRules: |-
    #   rule {
    #     source_labels = ["namespace"]
    #     regex         = "production"
    #     action        = "keep"
    #   }
    #   rule {
    #     action        = "replace"
    #     target_label  = "cluster"
    #     replacement   = "kube-prod-d1"
    #   }
  
  # apiServer:
  #   enabled: false
  
  kubeControllerManager:
    enabled: false
  
  kubeDNS:
    enabled: false
  
  kubeProxy:
    enabled: false
  
  kubeScheduler:
    enabled: false
  
  kube-state-metrics:
    enabled: true

    # extraMetricProcessingRules: |-
    #   rule {
    #     source_labels = ["namespace"]
    #     regex         = "production"
    #     action        = "keep"
    #   }
    #   rule {
    #     action        = "replace"
    #     target_label  = "cluster"
    #     replacement   = "kube-prod-d1"
    #   }

    # metricsTuning:
    #   useDefaultAllowList: false
    #   includeMetrics: [(.+)]
  
  node-exporter:
    enabled: true
    deploy: true

    # extraMetricProcessingRules: |-
    #   rule {
    #     source_labels = ["namespace"]
    #     regex         = "production"
    #     action        = "keep"
    #   }
    #   rule {
    #     action        = "replace"
    #     target_label  = "cluster"
    #     replacement   = "kube-prod-d1"
    #   }
      
    metricsTuning:
      useDefaultAllowList: false
      useIntegrationAllowList: true
  
  windows-exporter:
    enabled: false
    deploy: false
  
  kepler:
    enabled: true

    # extraMetricProcessingRules: |-
    #   rule {
    #     source_labels = ["namespace"]
    #     regex         = "production"
    #     action        = "keep"
    #   }
    #   rule {
    #     action        = "replace"
    #     target_label  = "cluster"
    #     replacement   = "kube-prod-d1"
    #   }
  
  opencost:
    enabled: false
    deploy: false

  nodeLabels:
    nodePool: true
    region: true
    availabilityZone: true
    nodeRole: true
    os: true
    architecture: true
    instanceType: true
 
clusterEvents:
  enabled: true
  
nodeLogs:
  enabled: false
  
podLogs:
  enabled: true

  nodeLabels:
    nodePool: true
    region: true
    availabilityZone: true
    nodeRole: true
    os: true
    architecture: true
    instanceType: true

  structuredMetadata:
    nodepool:
    region:
    availability_zone:
    node_role:
    os:
    architecture:
    instance_type:

  labelsToKeep:
    - app
    - app_kubernetes_io_name
    - component
    - container
    - job
    - level
    - namespace
    - pod
    - service_name
  
applicationObservability:
  enabled: true
  receivers:
    otlp:
      http:
        enabled: true
      grpc:
        enabled: true
  processors:
    k8sattributes:
      metadata:
        - k8s.namespace.name
        - k8s.pod.name
        - k8s.deployment.name
        - k8s.statefulset.name
        - k8s.daemonset.name
        - k8s.cronjob.name
        - k8s.job.name
        - k8s.node.name
        - k8s.pod.uid
        - k8s.pod.start_time
        - k8s.container.name

autoInstrumentation:
  enabled: true
 
annotationAutodiscovery:
  enabled: true

prometheusOperatorObjects:
  enabled: true

profiling:
  enabled: false
  
integrations:
  nodeLabels:
    nodepool: true
    region: true
    availability_zone: true
    node_role: true
    os: true
    architecture: true
    instance_type: true

  etcd:
    instances:
      - name: etcd
        labelSelectors:
          app.kubernetes.io/component: etcd
  alloy:
    instances:
      - name: alloy
        labelSelectors:
          app.kubernetes.io/name: [alloy-singleton, alloy-metrics, alloy-logs, alloy-profiles, alloy-receiver]
  cert-manager:
    instances:
      - name: cert-manager
        labelSelectors:
          app.kubernetes.io/name: cert-manager
  grafana:
    instances:
      - name: grafana
        labelSelectors:
          app.kubernetes.io/name: grafana
        namespaces:
          - grafana
  loki:
    instances:
      - name: loki
        labelSelectors:
          app.kubernetes.io/name: loki
        logs:
          enabled: true
          tuning:
            # extract logfmt fields and set them as structured metadata
            structuredMetadata:
              caller:
              tenant:
              org_id:
              user:
        namespaces:
          - loki
  mimir:
    instances:
      - name: mimir
        labelSelectors:
          app.kubernetes.io/name: mimir
        logs:
          enabled: true
          tuning:
            # extract logfmt fields and set them as structured metadata
            structuredMetadata:
              caller:
              tenant:
              org_id:
              user:
        namespaces:
          - mimir
  tempo:
    instances:
      - name: tempo
        labelSelectors:
          app.kubernetes.io/name: tempo
        logs:
          enabled: true
          tuning:
            # extract logfmt fields and set them as structured metadata
            structuredMetadata:
              caller:
              tenant:
              org_id:
              user:
        namespaces:
          - tempo

selfReporting:
  enabled: true

alloy-metrics:
  enabled: true
 
alloy-singleton:
  enabled: true
  
alloy-logs:
  enabled: true
  alloy:
    varlog: true
    dockercontainers: true

    extraEnv:
      - name: KUBE_NODE_NAME
        valueFrom:
          fieldRef:
            fieldPath: spec.nodeName
  extraConfig: |-
    loki.relabel "k3s_nodes_file_logs" {
      forward_to = [loki.write.locallogs.receiver]

      rule {
        source_labels = ["filename"]
        regex         = ".*/var/log/journal/.*"
        action        = "drop"
      }

      rule {
        source_labels = ["filename"]
        regex         = ".*/var/log/syslog/.*"
        action        = "drop"
      }

        rule {
        source_labels = ["filename"]
        regex         = ".*/var/log/pods/.*"
        action        = "drop"
      }

        rule {
        source_labels = ["filename"]
        regex         = ".*/var/log/containers/.*"
        action        = "drop"
      }

      rule {
        source_labels = ["filename"]
        regex         = ".*/var/log/([^/]+)/.*\\.log"
        target_label  = "filename_parent"
        replacement   = "$1"
      }

      rule {
        source_labels = ["filename"]
        regex         = ".*/var/log/.*/([^/]+)\\.log"
        target_label  = "filename_name"
        replacement   = "$1"
      }

      rule {
        action        = "replace"
        target_label  = "service"
        replacement   = string.format("%s-var-file-logs", sys.env("KUBE_NODE_NAME"))
      }

      rule {
        action       = "replace"
        target_label = "hostname"
        replacement  = sys.env("KUBE_NODE_NAME")
      }

      rule {
        action        = "replace"
        target_label  = "podname"
        replacement   = constants.hostname
      }
    }

    local.file_match "hostlogs" {
      path_targets = [{ __path__ = "/var/log/**/*.log" }]
      sync_period  = "5s"
    }

    loki.source.file "k3s_file_logs" {
      targets      = local.file_match.hostlogs.targets
      forward_to   = [ loki.relabel.k3s_nodes_file_logs.receiver ]
      tail_from_end = true
    }

    loki.relabel "k3s_nodes_journal" {
      forward_to = []

      rule {
        target_label  = "service"
        replacement   = string.format("%s-journal-logs", sys.env("KUBE_NODE_NAME"))
      }

      rule {
        source_labels = ["__journal__systemd_unit"]
        target_label  = "unit"
      }

      rule {
        source_labels = ["__journal__hostname"]
        target_label  = "hostname"
      }

      rule {
        source_labels = ["__journal__PRIORITY"]
        target_label  = "level"
      }

      rule {
        target_label  = "podname"
        replacement   = constants.hostname
      }
    }

    loki.source.journal "k3s_nodes_journal" {
      path           = "/var/log/journal"
      format_as_json = true

      labels = {
        job       = "k3s-systemd-journal",
        component = "k3s-journal-logs",
      }

      relabel_rules = loki.relabel.k3s_nodes_journal.rules
      forward_to    = [loki.write.locallogs.receiver]
    }
  
alloy-receiver:
  enabled: true
  alloy:
    extraPorts:
      # Zipkin
      - name: zipkin
        port:       9411
        targetPort: 9411
        protocol:   TCP

      # OTLP gRPC receiver
      - name: otlp-grpc
        port:       4317
        targetPort: 4317
        protocol:   TCP

      # OTLP HTTP/protobuf receiver
      - name: otlp-http
        port:       4318
        targetPort: 4318
        protocol:   TCP

alloy-profiles:
  enabled: false

alloy-operator:
  deploy: true
