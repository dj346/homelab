global:
  podAnnotations: {}
  podLabels: {}

  extraEnvFrom:
    - secretRef:
        name: mimir-s3-credentials

serviceAccount:
  annotations: {}
  labels: {}

# --Vault Agent config to mount secrets to TLS configurable components. This requires Vault and Vault Agent to already be running.
vaultAgent:
  enabled: false
  # -- Vault Kubernetes Authentication role
  roleName: ""
  # -- Path to client certificate in Vault
  clientCertPath: ""
  # -- Path to client key in Vault
  clientKeyPath: ""
  # -- Path to server certificate in Vault
  serverCertPath: ""
  # -- Path to server key in Vault
  serverKeyPath: ""
  # -- Path to client CA certificate in Vault
  caCertPath: ""

kedaAutoscaling:
  prometheusAddress: ""

mimir:
  structuredConfig:
    # limits:
    #   out_of_order_time_window: 5m

    common:
      storage:
        backend: s3
        s3:
          endpoint: minio:80
          region: us-west-1
          access_key_id: "${AWS_ACCESS_KEY_ID}" # This is a secret injected via an environment variable
          secret_access_key: "${AWS_SECRET_ACCESS_KEY}" # This is a secret injected via an environment variable
          insecure: true

    blocks_storage:
      s3:
        endpoint: minio:80
        region: us-west-1
        bucket_name: mimir-blocks
        access_key_id: "${AWS_ACCESS_KEY_ID}" # This is a secret injected via an environment variable
        secret_access_key: "${AWS_SECRET_ACCESS_KEY}" # This is a secret injected via an environment variable
        insecure: true

    alertmanager_storage:
      s3:
        endpoint: minio:80
        region: us-west-1
        bucket_name: mimir-alertmanager
        access_key_id: "${AWS_ACCESS_KEY_ID}" # This is a secret injected via an environment variable
        secret_access_key: "${AWS_SECRET_ACCESS_KEY}" # This is a secret injected via an environment variable
        insecure: true

    ruler_storage:
      s3:
        endpoint: minio:80
        region: us-west-1
        bucket_name: mimir-ruler
        access_key_id: "${AWS_ACCESS_KEY_ID}" # This is a secret injected via an environment variable
        secret_access_key: "${AWS_SECRET_ACCESS_KEY}" # This is a secret injected via an environment variable
        insecure: true

alertmanager:
  replicas: 1

  serviceAccount:
    annotations: {}
    labels: {}

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []
    # - port: 11811
    #   protocol: TCP
    #   name: reverse-proxy
    #   targetPort: 11811

  resources:
    requests:
      cpu: 10m
      memory: 32Mi

  podLabels: {}
  podAnnotations: {}

  annotations: {}
  persistentVolume:
    enabled: true
    name: storage
    annotations: {}
    accessModes:
      - ReadWriteOnce
    size: 1Gi
    subPath: ""
    storageClassName: longhorn
    enableRetentionPolicy: false
    whenDeleted: Retain
    whenScaled: Retain

distributor:
  replicas: 1

  service:
    annotations: {}
    labels: {}
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  resources:
    requests:
      cpu: 100m
      memory: 512Mi

  podLabels: {}
  podAnnotations: {}
  annotations: {}
  
ingester:
  replicas: 3

  service:
    annotations: {}
    labels: {}
    internalTrafficPolicy: Cluster
    type: ClusterIP

  resources:
    requests:
      cpu: 100m
      memory: 512Mi

  podLabels: {}
  podAnnotations: {}
  annotations: {}

  persistentVolume:
    enabled: true
    name: storage
    annotations: {}
    accessModes:
      - ReadWriteOnce
    size: 3Gi
    subPath: ""
    enableRetentionPolicy: false
    whenDeleted: Retain
    whenScaled: Retain
    storageClass: longhorn

overrides_exporter:
  enabled: true
  replicas: 1
  
  annotations: {}

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  podLabels: {}
  podAnnotations: {}

  resources:
    requests:
      cpu: 100m
      memory: 128Mi

ruler:
  replicas: 1

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  resources:
    requests:
      cpu: 100m
      memory: 128Mi

  podLabels: {}
  podAnnotations: {}

# -- Only deployed if .Values.ruler.remoteEvaluationDedicatedQueryPath
ruler_querier:
  replicas: 2

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  resources:
    requests:
      cpu: 100m
      memory: 128Mi

  podLabels: {}
  podAnnotations: {}
  annotations: {}
  
# -- Only deployed if .Values.ruler.remoteEvaluationDedicatedQueryPath
ruler_query_frontend:
  replicas: 1

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  resources:
    requests:
      cpu: 100m
      memory: 128Mi

  podLabels: {}
  podAnnotations: {}

  annotations: {}

# -- Only deployed if .Values.ruler.remoteEvaluationDedicatedQueryPath
ruler_query_scheduler:
  replicas: 2

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  resources:
    requests:
      cpu: 100m
      memory: 128Mi

querier:
  replicas: 2

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  resources:
    requests:
      cpu: 100m
      memory: 128Mi

  podLabels: {}
  podAnnotations: {}
  annotations: {}

query_frontend:
  replicas: 1

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  resources:
    requests:
      cpu: 100m
      memory: 128Mi

  podLabels: {}
  podAnnotations: {}
  annotations: {}
  
query_scheduler:
  replicas: 2

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  resources:
    requests:
      cpu: 100m
      memory: 128Mi

  podLabels: {}
  podAnnotations: {}
  annotations: {}

store_gateway:
  replicas: 1

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  resources:
    requests:
      cpu: 100m
      memory: 512Mi

  podLabels: {}
  podAnnotations: {}
  annotations: {}

  persistentVolume:
    enabled: true
    name: storage
    annotations: {}
    accessModes:
      - ReadWriteOnce
    size: 1Gi
    subPath: ""
    storageClass: "longhorn"
    enableRetentionPolicy: false
    whenDeleted: Retain
    whenScaled: Retain

compactor:
  replicas: 1

  service:
    annotations: {}
    labels: {}
    # -- https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    internalTrafficPolicy: Cluster
    type: ClusterIP
    extraPorts: []

  resources:
    requests:
      cpu: 100m
      memory: 512Mi

  podLabels: {}
  podAnnotations: {}
  annotations: {}

  persistentVolume:
    enabled: true
    name: storage
    annotations: {}
    accessModes:
      - ReadWriteOnce
    size: 3Gi
    subPath: ""
    storageClass: "longhorn"
    enableRetentionPolicy: false
    whenDeleted: Retain
    whenScaled: Retain

memcachedExporter:
  resources:
    requests: {}
    limits: {}

minio:
  enabled: false
  mode: standalone
  rootUser: grafana-mimir
  rootPassword: supersecret
  buckets:
    - name: mimir-tsdb
      policy: none
      purge: false
    - name: mimir-ruler
      policy: none
      purge: false
    - name: enterprise-metrics-tsdb
      policy: none
      purge: false
    - name: enterprise-metrics-admin
      policy: none
      purge: false
    - name: enterprise-metrics-ruler
      policy: none
      purge: false
  
  persistence:
    size: 5Gi
  
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
  
gateway:
  enabled: true
  enabledNonEnterprise: true
  replicas: 1

  podLabels: {}
  podAnnotations: {}
  
  resources: {}
  annotations: {}

  service:
    port: 80
    type: ClusterIP
    clusterIP: null
    nodePort: null
    loadBalancerIP: null
    annotations: {}
    labels: {}
    nameOverride: ""
    internalTrafficPolicy: Cluster
    extraPorts: []

metaMonitoring:
  dashboards:
    enabled: true
    namespace: grafana
    annotations:
      k8s-sidecar-target-directory: /tmp/dashboards/Mimir
    labels:
      grafana_dashboard: "1"

  # ServiceMonitor configuration for monitoring Kubernetes Services with Prometheus Operator and/or Grafana Agent
  serviceMonitor:
    enabled: true
    clusterLabel: ""
    namespace: null
    namespaceSelector: null
    annotations: {}
    labels: {}

  prometheusRule:
    enabled: true
    mimirAlerts: false
    mimirRules: false
    annotations: {}
    labels: {}
    namespace: null
 
  grafanaAgent:
    enabled: false
    resources:
    #   configReloader:
    #     requests:
    #       cpu: 5m
    #       memory: 10Mi
    #     limits:
    #       memory: 50Mi
    #   grafanaAgent:
    #     requests:
    #       cpu: 20m
    #       memory: 700Mi
    #     limits:
    #       memory: 1400Mi

    # -- Controls whether to install the Grafana Agent Operator and its CRDs.
    # Note that helm will not install CRDs if this flag is enabled during an upgrade.
    # In that case install the CRDs manually from https://github.com/grafana/agent/tree/main/operations/agent-static-operator/crds
    installOperator: false

    logs:
      enabled: true
      clusterLabel: ""
      remote:
        url: ""
        auth:
          tenantId: ""
          username: ""
          passwordSecretName: ""
          passwordSecretKey: ""

    metrics:
      enabled: true
      remote:
        url: ""
        headers: {}
        auth:
          username: ""
          passwordSecretName: ""
          passwordSecretKey: ""

      scrapeK8s:
        # -- When grafanaAgent.enabled and serviceMonitor.enabled, controls whether to create ServiceMonitors CRs
        # for cadvisor, kubelet, and kube-state-metrics. The scraped metrics are reduced to those pertaining to
        # Mimir pods only.
        enabled: true

    labels: {}
    annotations: {}