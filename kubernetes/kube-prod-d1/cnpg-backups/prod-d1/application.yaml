apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: cnpg-backups-application
  namespace: argocd
  labels:
    app.kubernetes.io/name: cnpg-backups
    app.kubernetes.io/component: application
    app.kubernetes.io/instance: cnpg-backups-prod-d1
    app.kubernetes.io/managed-by: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "1"
    description: "ArgoCD managed deployment for SeaweedFS Backups (CloudNative Postgres Containers) application in production"
spec:
  project: default
  revisionHistoryLimit: 5
  destination:
    server: https://kubernetes.default.svc
    namespace: cnpg-backups
  sources:
    - repoURL: https://seaweedfs.github.io/seaweedfs/helm
      chart: seaweedfs
      targetRevision: 4.0.400
      helm:
        valuesObject:
          # image:
          #   registry: ""
          #   repository: ""
          #   tag: ""

          global:
            loggingLevel: 1
            createClusterRole: true
            enableSecurity: true
            masterServer: seaweedfs-master.cnpg-backups.kube-prod-d1i.mclacken.net:9333

            securityConfig:
              jwtSigning: 
                volumeWrite: true   # -> [jwt.signing]
                volumeRead: false   # -> [jwt.signing.read]
                filerWrite: true    # -> [jwt.filer_signing]
                filerRead: false    # -> [jwt.filer_signing.read]

            monitoring:
              enabled: false
              additionalLabels: {}

            extraEnvironmentVars:
              WEED_CLUSTER_DEFAULT: "backup-seaweedfs-prod-d1"
              WEED_CLUSTER_SW_MASTER: "seaweedfs-master.cnpg-backups.kube-prod-d1i.mclacken.net:9333"
              WEED_CLUSTER_SW_FILER: "seaweedfs-filer-client.cnpg-backups.kube-prod-d1i.mclacken.net:8888"

              WEED_JWT_SIGNING_KEY:
                secretKeyRef:
                  name: swb-jwt-signing-key-template-secret
                  key: signingKey
          
          certificates:
            externalCertificates:
              # This will avoid the need to use cert-manager and will rely on providing your own external certificates and CA
              # you will need to store your provided certificates in the secret read by the different services:
              # seaweedfs-master-cert, seaweedfs-filer-cert, etc. Can see any statefulset definition to see secret names
              enabled: true
          
          masterServer:
            enabled: true
            # imageOverride: null
            # restartPolicy: null
            replicas: 3

            port: 9333
            grpcPort: 19333
            metricsPort: 9327

            volumeSizeLimitMB: 1000 # 1GB per volume limit 
            loggingOverrideLevel: null
            garbageThreshold: null # fraction of “wasted” space before vacuum/compaction kicks in (e.g. 0.3 means 30% garbage).
            metricsIntervalSec: 15
            
            disableHttp: false # if true, only gRPC operations are allowed; HTTP endpoints disabled (more locked-down).
            resumeState: true # resume previous master state at startup (useful for HA clusters).
            raftHashicorp: false # use Hashicorp Raft implementation instead of the built-in one.
            raftBootstrap: false
        
            data:
              type: "persistentVolumeClaim"
              size: "20Gi"
              storageClass: "longhorn-strict-local"
              annotations: {}
              hostPathPrefix: /master

            logs:
              type: "emptyDir"
                
            sidecars: []
            initContainers: ""
            extraVolumes: ""
            extraVolumeMounts: ""

            podLabels: {}
            podAnnotations: {}
            annotations: {}
            resources: {}

            affinity: |
              podAntiAffinity:
                requiredDuringSchedulingIgnoredDuringExecution:
                  - labelSelector:
                      matchLabels:
                        app.kubernetes.io/name: seaweedfs
                        app.kubernetes.io/instance: cnpg-backups-application
                        app.kubernetes.io/component: master
                    topologyKey: kubernetes.io/hostname

            topologySpreadConstraints: ""
            tolerations: ""
            nodeSelector: ""
            priorityClassName: ""
            serviceAccountName: ""
            


          filer:
            enabled: true
            replicas: 2

            s3:
              enabled: true
              enableAuth: true
              existingConfigSecret: s3-credentials-secret

            extraEnvironmentVars:
              WEED_POSTGRES_ENABLED: "true"
              WEED_POSTGRES_HOSTNAME: "cnpg-backups-postgres-cluster-rw.cnpg-backups.kube-prod-d1i.mclacken.net."
              WEED_POSTGRES_PORT: "5432"
              WEED_POSTGRES_DATABASE: "filemeta"
              WEED_POSTGRES_USERNAME: "seaweedfs-backup"
              WEED_POSTGRES_PASSWORD: "seaewoodfs-password"
              WEED_POSTGRES_SSLMODE: "disable"
              # WEED_POSTGRES_CONNECTION_MAX_IDLE: 5    
              # WEED_POSTGRES_CONNECTION_MAX_OPEN: 75
              # WEED_POSTGRES_CONNECTION_MAX_LIFETIME_SECONDS: 600
              WEED_LEVELDB2_ENABLED: "false"
              
    - repoURL: 'ssh://git@gitea-ssh.gitea.svc.cluster.local:2222/dj346/homelab.git'
      targetRevision: HEAD
      path: kubernetes/kube-prod-d1/cnpg-backups/prod-d1
  syncPolicy:
    syncOptions:
      - Validate=true
      - PrunePropagationPolicy=foreground
    automated:
      prune: true
      selfHeal: true
    retry:
      limit: 5
      backoff:
        duration: 10s
        factor: 2
        maxDuration: 5m
