labels:
  app.kubernetes.io/name: authelia
  app.kubernetes.io/instance: authelia-prod-d1
  app.kubernetes.io/managed-by: argocd

annotations: {}

rbac:
  enabled: false
  annotations: {}
  labels.app.kubernetes.io/component: rbac
  serviceAccountName: 'authelia-service-account'

service:
  type: 'ClusterIP'
  annotations: {}
  labels.app.kubernetes.io/component: networking
  port: 80
  nodePort: 30091
  clusterIP: ~
  externalTrafficPolicy: ~

pod:
  kind: 'Deployment'
  replicas: 3

  labels.app.kubernetes.io/component: program
  annotations.reloader.stakater.com/auto: "true"

  command: []
  args: []

  initContainers: []
  
  disableRestartOnChanges: false
  revisionHistoryLimit: 5
  priorityClassName: 'critical-priority'

  # autoscaling:
  #   enabled: false
  #   annotations: {}

  #   labels: {}
  #   behavior: {}

  strategy:
    type: 'RollingUpdate'
    rollingUpdate:
      partition: 0
      maxSurge: '25%'
      maxUnavailable: '25%'
  
  securityContext:
    pod:
      runAsNonRoot: true
      runAsUser: 1000
      runAsGroup: 1000

      fsGroup: 1000
      fsGroupChangePolicy: "OnRootMismatch"

      seccompProfile.type: RuntimeDefault

    container:
      runAsNonRoot: true
      runAsUser: 1000
      runAsGroup: 1000

      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true

      capabilities.drop:
        - ALL

      seccompProfile.type: RuntimeDefault

  # tolerations: []

    selectors:
      affinity:
        podAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 80
              podAffinityTerm:
                labelSelector:
                  matchLabels:
                    cnpg.io/cluster: authelia-postgresql-cluster
                topologyKey: kubernetes.io/hostname
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchLabels:
                      app.kubernetes.io/name: authelia
                      app.kubernetes.io/component: program
                      app.kubernetes.io/instance: authelia-prod-d1
                      app.kubernetes.io/managed-by: argocd
                topologyKey: kubernetes.io/hostname
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: "node-role.kubernetes.io/control-plane"
                    operator: DoesNotExist

  env:
    - name: "TZ"
      value: "America/Los_Angeles"
  
  resources:
  
  probes:
    method.httpGet:
      path: '/api/health'
      port: 'http'
      scheme: 'HTTP'

    liveness:
      initialDelaySeconds: 0
      periodSeconds: 30
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 5

    readiness:
      initialDelaySeconds: 0
      periodSeconds: 5
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 5

    startup:
      initialDelaySeconds: 10
      periodSeconds: 5
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 6

  extraVolumes:
    - name: authelia-server-certificate-secret-volume
      secret:
        secretName: authelia-server-certificate-secret
  
  extraVolumeMounts:
    - name: authelia-server-certificate-secret-volume
      mountPath: /secrets/server-tls
      readOnly: true
      
  extraContainers: []

podDisruptionBudget:
  enabled: true
  
  minAvailable: 0
  maxUnavailable: 1
  
  annotations: {}
  labels.app.kubernetes.io/component: program

configMap:
  disabled: false
  default_2fa_method: '' # totp, webauthn, mobile_push
  theme: 'dark'
  
  annotations: {}
  labels:
    app.kubernetes.io/component: program
  
  existingConfigMap: ''
  extraConfigs: []
  key: 'configuration.yaml'

  server:
    port: 9091

    tls:
      certificate: /secrets/server-tls/tls.crt
      key: /secrets/server-tls/tls.key

    endpoints:
      authz:
        forward-auth:
          implementation: "ForwardAuth"
          authn_strategies:
            - name: "HeaderAuthorization"
              schemes:
                - "Bearer"
                - "Basic"
              scheme_basic_cache_lifespan: 10m
            - name: "CookieSession"
        forward-auth/basic:
          implementation: "ForwardAuth"
          authn_strategies:
            - name: "CookieSession"

  log:
    level: 'info'
    format: 'json'
    file_path: ''

  telemetry:
    metrics:
      enabled: false
      port: 9959

      serviceMonitor:
        enabled: false
        annotations: {}
        labels: 
          app.kubernetes.io/component: monitoring

  definitions:
    network:
      INTERNAL:
        - 10.15.21.0/24    # example
      

    user_attributes: {}
    # user_attributes:
      ## Boolean attribute example
      # is_admin:
        # expression: '"admin" in groups'
      ## String attribute example
      # department:
        # expression: 'groups[0]'
      ## Number attribute example
      # access_level:
        # expression: '"admin" in groups ? 10 : 5'

  identity_validation:
    reset_password:
      jwt_lifespan: '5 minutes'

      secret:
        secret_name: authelia-reset-jwt-hmac-key-secret
        path: authelia-reset-jwt-hmac-key-secret

    elevated_session:
      require_second_factor: true
      skip_second_factor: false

  totp:
    disable: false
    issuer: 'mclacken.net'
    
    skew: 1
    secret_size: 32
    period: 30

    allowed_algorithms:
    - sha1
    - sha256
    - sha512
    
    allowed_digits:
      - 6
      - 8

    allowed_periods:
      - 30

  webauthn:
    disable: false

    enable_passkey_login: true
    display_name: 'mclacken.net'
    attestation_conveyance_preference: 'direct'

    metadata:
      enabled: true
      cache_policy: relaxed
      validate_trust_anchor: true
      validate_entry: true
      validate_status: true
      validate_entry_permit_zero_aaguid: true

  ntp:
    address: 'udp://time.cloudflare.com:123'
    version: 4
    max_desync: '3 seconds'

  duo_api:
    enabled: true

    hostname: 'api-2e6db46d.duosecurity.com'
    integration_key: 'DIEDSZEQ5YSV52KRX738'

    enable_self_enrollment: true

    secret:
      secret_name: authelia-duo-api-token-secret
      path: authelia-duo-api-token-secret

  authentication_backend:
    password_reset:
      disable: false
      custom_url: ''

    password_change.disable: false

    # -- The amount of time to wait before we refresh data from the authentication backend. Uses duration notation.
    refresh_interval: '5 minutes'

    ldap:
      enabled: true
      implementation: lldap
      address: ldap://lldap-service.lldap.svc.cluster.local:3890
      timeout: 5 seconds
      base_dn: DC=mclacken,DC=net
      pooling:
        enable: false
      
      user: uid=authelia-bind-account,ou=people,dc=mclacken,dc=net
      password:
        secret_name: "authelia-lldap-bind-account-password-secret"
        path: "authelia-lldap-bind-account-password-secret"

      additional_users_dn: OU=people
      additional_groups_dn: OU=groups
      users_filter: (&(|({username_attribute}={input})({mail_attribute}={input}))(objectClass=person)(memberOf=cn=authelia-user,ou=groups,dc=mclacken,dc=net))
      groups_filter: (&(member={dn})(objectClass=groupOfNames))
      attributes:
        username: uid
        display_name: displayName
        mail: mail
      # NOTE: keep secrets out of configMap; see note below.

  password_policy.zxcvbn:
    enabled: true
    min_score: 4

  access_control:
    default_policy: 'deny'

    rules:
      - domain:
          - anisonarr.kube-prod-d1.mclacken.net
        policy:
          - one_factor
        subjects:
          - group:anisonarr-admin
    
  session:
    name: 'authelia_session'

    same_site: 'lax'
    expiration: '1 hour'
    inactivity: '5 minutes'
    remember_me: '1 month'

    encryption_key:
      secret_name: authelia-cookie-session-encryption-key-secret
      path: authelia-cookie-session-encryption-key-secret

    cookies:
      - domain: "mclacken.net"
        subdomain: "authelia.kube-prod-d1"
        name: "mclacken_authelia_session"

    redis:
      # -- Enable the use of redis.
      enabled: false

      # -- Deploy the redis bitnami chart.
      deploy: false

      # -- The redis host or unix socket path. If utilising an IPv6 literal address it must be enclosed by square
      # brackets and quoted.
      host: 'redis.databases.svc.cluster.local'

      # -- The port redis is listening on.
      port: 6379

      # -- Optional username to be used with authentication.
      username: ''

      password:
        # -- Disables this secret and leaves configuring it entirely up to you.
        disabled: false

        # -- (string) The secret name. The ~ name is special as it is the secret we generate either automatically or via the
        # secret_value option below.
        secret_name: ~

        # -- The value of a generated secret when using the ~ secret_name.
        value: ''

        # -- The path to the secret. If it has a '/' prefix it's assumed to be an absolute path within the pod. Otherwise
        # it uses the format '{mountPath}/{secret_name}/{path}' where '{mountPath}' refers to the 'secret.mountPath'
        # value, '{secret_name}' is the secret_name above, and '{path}' is this value.
        path: 'session.redis.password.txt'

      # -- This is the Redis DB Index https://redis.io/commands/select (sometimes referred to as database number, DB, etc).
      database_index: 0

      # -- The maximum number of concurrent active connections to Redis.
      maximum_active_connections: 8

      # -- The target number of idle connections to have open ready for work. Useful when opening connections is slow.
      minimum_idle_connections: 0

      ## The Redis TLS configuration. If defined will require a TLS connection to the Redis instance(s).
      tls:
        # -- Enables rendering this TLS config.
        enabled: false

        # -- The server subject name to check the servers certificate against during the validation process.
        # This option is not required if the certificate has a SAN which matches the host option.
        server_name: ''

        # -- Skip verifying the server certificate entirely.
        skip_verify: false

        # -- Minimum TLS version for the connection.
        minimum_version: 'TLS1.2'

        # -- Maximum TLS version for the connection.
        maximum_version: 'TLS1.3'

      ## The Redis HA configuration options.
      ## This provides specific options to Redis Sentinel, sentinel_name must be defined (Master Name).
      high_availability:
        # -- Enable the use of redis sentinel.
        enabled: false

        # -- Sentinel Name / Master Name
        sentinel_name: 'mysentinel'

        # -- The Redis Sentinel-specific username. If supplied, authentication will be done via Redis 6+ ACL-based
        # authentication. If left blank, authentication to sentinels will be done via `requirepass`.
        username: ''

        password:
          # -- Disables this secret and leaves configuring it entirely up to you.
          disabled: false

          # -- The secret name. The ~ name is special as it is the secret we generate either automatically or via the
          # secret_value option below.
          secret_name: ~

          # -- The value of a generated secret when using the ~ secret_name.
          value: ''

          # -- The path to the secret. If it has a '/' prefix it's assumed to be an absolute path within the pod. Otherwise
          # it uses the format '{mountPath}/{secret_name}/{path}' where '{mountPath}' refers to the 'secret.mountPath'
          # value, '{secret_name}' is the secret_name above, and '{path}' is this value.
          path: 'session.redis.sentinel.password.txt'

        # -- The additional nodes to pre-seed the redis provider with (for sentinel).
        # If the host in the above section is defined, it will be combined with this list to connect to sentinel.
        # For high availability to be used you must have either defined; the host above or at least one node below.
        nodes: []
        # nodes:
        #   - host: 'sentinel-0.databases.svc.cluster.local'
        #     port: 26379
        #   - host: 'sentinel-1.databases.svc.cluster.local'
        #     port: 26379

        # -- Choose the host with the lowest latency.
        route_by_latency: false

        # -- Choose the host randomly.
        route_randomly: false

  regulation:
    # -- The regulation modes to use. The active modes determines what is banned in the event of a regulation ban being
    # triggered as well as what logs to inspect to determine if a ban is needed. Default is just user, but ip is also
    # available.
    modes:
      - 'user'

    # -- The number of failed login attempts before user is banned. Set it to 0 to disable regulation.
    max_retries: 3

    # -- The time range during which the user can attempt login before being banned. The user is banned if the
    # authentication failed 'max_retries' times in a 'find_time' window. Find Time accepts duration notation.
    # See: https://www.authelia.com/configuration/prologue/common/#duration-notation-format
    find_time: '2 minutes'

    # -- The length of time before a banned user can login again. Ban Time accepts duration notation.
    # See: https://www.authelia.com/configuration/prologue/common/#duration-notation-format
    ban_time: '5 minutes'

  storage:
    encryption_key:
      # -- Disables this secret and leaves configuring it entirely up to you.
      disabled: false

      # -- The secret name. The ~ name is special as it is the secret we generate either automatically or via the
      # secret_value option below.
      secret_name: ~

      # -- The value of a generated secret when using the ~ secret_name.
      value: ''

      # -- The path to the secret. If it has a '/' prefix it's assumed to be an absolute path within the pod. Otherwise
      # it uses the format '{mountPath}/{secret_name}/{path}' where '{mountPath}' refers to the 'secret.mountPath'
      # value, '{secret_name}' is the secret_name above, and '{path}' is this value.
      path: 'storage.encryption.key'

    local:
      # -- Enable the Local Provider (Storage / SQL)
      enabled: false

      # -- Path to the SQLite3 database.
      path: '/config/db.sqlite3'

    mysql:
      # -- Enable the MySQL Provider (Storage / SQL).
      enabled: false

      # -- Deploy the MySQL Chart.
      deploy: false

      # -- Configures the address for the MySQL/MariaDB Server. The address itself is a connector and the scheme must
      # either be the unix scheme or one of the tcp schemes.
      address: 'tcp://mysql.databases.svc.cluster.local:3306'

      # -- The SQL connection timeout.
      timeout: '5 seconds'

      # -- The database name on the database server that the assigned user has access to for the purpose of Authelia.
      database: 'authelia'

      # -- The username paired with the password used to connect to the database.
      username: 'authelia'

      password:
        # -- Disables this secret and leaves configuring it entirely up to you.
        disabled: false

        # -- The secret name. The ~ name is special as it is the secret we generate either automatically or via the
        # secret_value option below.
        secret_name: ~

        # -- The value of a generated secret when using the ~ secret_name.
        value: ''

        # -- The path to the secret. If it has a '/' prefix it's assumed to be an absolute path within the pod. Otherwise
        # it uses the format '{mountPath}/{secret_name}/{path}' where '{mountPath}' refers to the 'secret.mountPath'
        # value, '{secret_name}' is the secret_name above, and '{path}' is this value.
        path: 'storage.mysql.password.txt'

      tls:
        # -- Enables rendering this TLS config.
        enabled: false

        # -- The server subject name to check the servers certificate against during the validation process.
        # This option is not required if the certificate has a SAN which matches the host option.
        server_name: ''

        # -- Skip verifying the server certificate entirely.
        skip_verify: false

        # -- Minimum TLS version for the connection.
        minimum_version: 'TLS1.2'

        # -- Maximum TLS version for the connection.
        maximum_version: 'TLS1.3'

    postgres:
      # -- Enable the PostgreSQL Provider (Storage / SQL).
      enabled: false

      # -- Deploy the PostgreSQL Chart.
      deploy: false

      # -- Configures the address for the PostgreSQL Server. The address itself is a connector and the scheme must
      # either be the unix scheme or one of the tcp schemes.
      address: 'tcp://postgres.databases.svc.cluster.local:5432'

      # -- This specifies a list of additional fallback PostgreSQL instances to use should issues occur with the primary
      # instance which is configured with the address and tls options.
      servers: []
      # servers:
        # - address: 'tcp://postgres2:5432'
        #   tls:
        #     server_name: 'postgres2.local'
        # - address: 'tcp://postgres3:5432'
        #   tls:
        #     server_name: 'postgres3.local'

      # -- The SQL connection timeout.
      timeout: '5 seconds'

      # -- The database name on the database server that the assigned user has access to for the purpose of Authelia.
      database: 'authelia'

      # -- The database schema name to use on the database server that the assigned user has access to for the purpose
      # of Authelia. By default this is the public schema.
      schema: 'public'

      # -- The username paired with the password used to connect to the database.
      username: 'authelia'

      password:
        # -- Disables this secret and leaves configuring it entirely up to you.
        disabled: false

        # -- The secret name. The ~ name is special as it is the secret we generate either automatically or via the
        # secret_value option below.
        secret_name: ~

        # -- The value of a generated secret when using the ~ secret_name.
        value: ''

        # -- The path to the secret. If it has a '/' prefix it's assumed to be an absolute path within the pod. Otherwise
        # it uses the format '{mountPath}/{secret_name}/{path}' where '{mountPath}' refers to the 'secret.mountPath'
        # value, '{secret_name}' is the secret_name above, and '{path}' is this value.
        path: 'storage.postgres.password.txt'

      tls:
        # -- Enables rendering this TLS config.
        enabled: false

        # -- The server subject name to check the servers certificate against during the validation process.
        # This option is not required if the certificate has a SAN which matches the host option.
        server_name: ''

        # -- Skip verifying the server certificate entirely.
        skip_verify: false

        # -- Minimum TLS version for the connection.
        minimum_version: 'TLS1.2'

        # -- Maximum TLS version for the connection.
        maximum_version: 'TLS1.3'

  notifier:
    # -- You can disable the notifier startup check by setting this to true.
    disable_startup_check: false

    filesystem:
      # -- Enables the File System Provider (Notifier).
      enabled: false

      # -- The file to add email text to. If it doesnâ€™t exist it will be created.
      filename: '/config/notification.txt'

    smtp:
      # -- Enables the SMTP Provider (Notifier).
      enabled: false

      # -- Configures the address for the SMTP Server. The address itself is a connector and the scheme must be smtp,
      # submission, or submissions. The only difference between these schemes are the default ports and submissions
      # requires a TLS transport per SMTP Ports Security Measures, whereas submission and smtp use a standard TCP
      # transport and typically enforce StartTLS.
      address: 'submission://smtp.mail.svc.cluster.local:587'

      # -- The SMTP connection timeout.
      timeout: '5 seconds'

      # -- The sender is used to construct both the SMTP command MAIL FROM and to add the FROM header. This address must
      # be in RFC5322 format.
      sender: 'Authelia <admin@example.com>'

      # -- HELO/EHLO Identifier. Some SMTP Servers may reject the default of localhost.
      identifier: 'localhost'

      # -- Subject configuration of the emails sent.
      # {title} is replaced by the text from the notifier
      subject: '[Authelia] {title}'

      # -- This address is used during the startup check to verify the email configuration is correct.
      # It's not important what it is except if your email server only allows local delivery.
      startup_check_address: 'test@authelia.com'

      # -- Disables sending HTML formatted emails.
      disable_html_emails: false

      # -- By default we require some form of TLS. This disables this check though is not advised.
      disable_require_tls: false

      # -- Some SMTP servers ignore SMTP specifications and claim to support STARTTLS when they in fact do not. For
      # security reasons Authelia refuses to send messages to these servers. This option disables this measure and is
      # enabled AT YOUR OWN RISK.
      disable_starttls: false

      # -- The username sent for authentication with the SMTP server. Paired with the password.
      username: ''

      password:
        # -- Disables this secret and leaves configuring it entirely up to you.
        disabled: false

        # -- The secret name. The ~ name is special as it is the secret we generate either automatically or via the
        # secret_value option below.
        secret_name: ~

        # -- The value of a generated secret when using the ~ secret_name.
        value: ''

        # -- The path to the secret. If it has a '/' prefix it's assumed to be an absolute path within the pod. Otherwise
        # it uses the format '{mountPath}/{secret_name}/{path}' where '{mountPath}' refers to the 'secret.mountPath'
        # value, '{secret_name}' is the secret_name above, and '{path}' is this value.
        path: 'notifier.smtp.password.txt'

      tls:
        # -- The server subject name to check the servers certificate against during the validation process.
        # This option is not required if the certificate has a SAN which matches the host option.
        server_name: ''

        # -- Skip verifying the server certificate entirely.
        skip_verify: false

        # -- Minimum TLS version for the connection.
        minimum_version: 'TLS1.2'

        # -- Maximum TLS version for the connection.
        maximum_version: 'TLS1.3'

  identity_providers:
    oidc:
      # -- Enables this in the config map. Currently in beta stage.
      # See https://www.authelia.com/r/openid-connect/
      enabled: false

      hmac_secret:
        # -- Disables this secret and leaves configuring it entirely up to you.
        disabled: false

        # -- The secret name. The ~ name is special as it is the secret we generate either automatically or via the
        # secret_value option below.
        secret_name: ~

        # -- The value of a generated secret when using the ~ secret_name.
        value: ''

        # -- The path to the secret. If it has a '/' prefix it's assumed to be an absolute path within the pod. Otherwise
        # it uses the format '{mountPath}/{secret_name}/{path}' where '{mountPath}' refers to the 'secret.mountPath'
        # value, '{secret_name}' is the secret_name above, and '{path}' is this value.
        path: 'identity_providers.oidc.hmac.key'

      lifespans:
        # -- Default lifespan for Access Tokens.
        access_token: '1 hour'

        # -- Default lifespan for Refresh Tokens.
        refresh_token: '1 hour and 30 minutes'

        # -- Default lifespan for ID Tokens.
        id_token: '1 hour'

        # -- Default lifespan for Authorize Codes.
        authorize_code: '1 minute'

        # -- Default lifespan for Device Codes.
        device_code: '10 minutes'

        # -- The custom lifespan configuration allows customizing the lifespans per-client. The custom lifespans must be
        # utilized with the client lifespan option which applies those settings to that client. Custom lifespans can be
        # configured in a very granular way, either solely by the token type, or by the token type for each grant type.
        custom: {}
        # custom:
        #   lifespan_name:
        #     access_token: '1 hour'
        #     refresh_token: '1 hour and 30 minutes'
        #     id_token: '1 hour'
        #     authorize_code: '1 minute'
        #     device_code: '10 minutes'
        #     grants:
        #       authorize_code:
        #         access_token: '1 hour'
        #         refresh_token: '1 hour and 30 minutes'
        #         id_token: '1 hour'
        #       device_code:
        #         access_token: '1 hour'
        #         refresh_token: '1 hour and 30 minutes'
        #         id_token: '1 hour'
        #       implicit:
        #         access_token: '1 hour'
        #         refresh_token: '1 hour and 30 minutes'
        #         id_token: '1 hour'
        #       client_credentials:
        #         access_token: '1 hour'
        #         refresh_token: '1 hour and 30 minutes'
        #         id_token: '1 hour'
        #       refresh_token:
        #         access_token: '1 hour'
        #         refresh_token: '1 hour and 30 minutes'
        #         id_token: '1 hour'
        #       jwt_bearer:
        #         access_token: '1 hour'
        #         refresh_token: '1 hour and 30 minutes'
        #         id_token: '1 hour'

      # -- The claims policies are policies which allow customizing the behavior of claims and the available claims for
      # a particular client.
      claims_policies: {}
      # claims_policies:
        # policy_name:
          # id_token: []
          # access_token: []
          # id_token_audience_mode: 'specification'
          # custom_claims:
            # claim_name:
              # attribute: 'attribute_name'

      # -- A list of scope definitions available in addition to the standard ones.
      scopes: {}
      # scopes:
        # scope_name:
          # claims: []

      # -- Adjusts the PKCE enforcement. Options are always, public_clients_only, never.
      # For security reasons it's recommended this option is public_clients_only or always, however always is not
      # compatible with all clients.
      enforce_pkce: 'public_clients_only'

      # -- Enables the plain PKCE challenge which is not recommended for security reasons but may be necessary for some clients.
      enable_pkce_plain_challenge: false

      # -- Enables introspecting JWT Profile Access Tokens using stateless checks. This is strongly discouraged.
      enable_jwt_access_token_stateless_introspection: false

      # -- The JSON Web Algorithm used for signing the discovery metadata.
      discovery_signed_response_alg: ''

      # -- The JSON Web Key ID used for signing the discovery metadata.
      discovery_signed_response_key_id: ''

      # -- Enables requiring all Authorization Requests to be initiated using a Pushed Authorization Request.
      require_pushed_authorization_requests: false

      # -- Adjusts the parameter entropy requirements for nonce/state etc. SECURITY NOTICE: It's not recommended changing
      # this option, and highly discouraged to have it less than 8.
      minimum_parameter_entropy: 8

      # -- Enables additional debug messages. SECURITY NOTICE: It's not recommended to use this in production as it
      # may leak configuration information to clients.
      enable_client_debug_messages: false

      pushed_authorizations:
        # -- Requires Pushed Authorization Requests for all Authorization Flows.
        enforce: false

        # -- Adjusts the lifespan for a Pushed Authorization session / context.
        context_lifespan: '5 minutes'

      # -- Authorization Policies configuration.
      authorization_policies: {}

      # authorization_policies:
      #   policy_name:
      #     default_policy: 'deny'
      #     rules:
      #       - policy: 'two_factor'
      #         subject: 'user:abc'

      # -- The JWK's issuer option configures multiple JSON Web Keys. It's required that at least one of the JWK's
      # configured has the RS256 algorithm. For RSA keys (RS or PS) the minimum is a 2048 bit key.
      jwks: []

      # jwks:
      #   - key_id: ''
      #     algorithm: 'RS256'
      #     use: 'sig'
      #     key:
      #       value: |
      #         abc
      #         123
      #       path: '/secrets/oidc.jwk.RS256.pem'
      #     certificate_chain:
      #       path: '/secrets.oidc.jwk.RS256.crt'

      ## Cross-Origin Resource Sharing (CORS) settings.
      cors:
        # -- List of endpoints in addition to the metadata endpoints to permit cross-origin requests on.
        endpoints: []

        # -- List of allowed origins.
        # Any origin with https is permitted unless this option is configured or the
        # allowed_origins_from_client_redirect_uris option is enabled.
        allowed_origins: []

        # -- Automatically adds the origin portion of all redirect URI's on all clients to the list of allowed_origins,
        # provided they have the scheme http or https and do not have the hostname of localhost.
        allowed_origins_from_client_redirect_uris: false

      # -- List of registered clients for this provider.
      clients: []
      # clients:
        # -
          ## The ID is the OpenID Connect ClientID which is used to link an application to a configuration.
          # client_id: 'myapp'

          ## The description to show to users when they end up on the consent screen. Defaults to the ID above.
          # client_name: 'My Application'

          ## The client secret is a shared secret between Authelia and the consumer of this client.
          # client_secret:
            # value: '$plaintext$apple123'
            # path: '/secrets/oidc.client.myapp.value'

          ## Sector Identifiers are occasionally used to generate pairwise subject identifiers. In most cases this is not
          ## necessary. Read the documentation for more information.
          ## The subject identifier must be the host component of a URL, which is a domain name with an optional port.
          # sector_identifier_uri: 'example.com'

          ## Sets the client to public. This should typically not be set, please see the documentation for usage.
          # public: false

          ## Redirect URI's specifies a list of valid case-sensitive callbacks for this client.
          # redirect_uris:
          #   - 'https://oidc.example.com/oauth2/callback'

          ## Request URI's specifies a list of valid case-sensitive URIs this client can ask Authelia to obtain a
          ## Request Object from.
          # request_uris:
          #   - 'https://oidc.example.com/oauth2/request-object/authelia.jwk'

          ## Audience this client is allowed to request.
          # audience: []

          ## Scopes this client is allowed to request.
          # scopes:
          #   - 'openid'
          #   - 'profile'
          #   - 'email'
          #   - 'groups'

          ## Grant Types configures which grants this client can obtain.
          ## It's not recommended to configure this unless you know what you're doing.
          # grant_types:
          #   - 'refresh_token'
          #   - 'authorization_code'

          ## Response Types configures which responses this client can be sent.
          ## It's not recommended to configure this unless you know what you're doing.
          # response_types:
          #   - 'code'

          ## Response Modes configures which response modes this client supports.
          ## It's not recommended to configure this unless you know what you're doing.
          # response_modes:
          #   - 'form_post'
          #   - 'query'
          #   - 'fragment'

          ## The policy to require for this client; one_factor or two_factor.
          # authorization_policy: 'two_factor'

          # lifespan: ''

          # claims_policy: ''

          # requested_audience_mode: ''

          ## The consent mode controls how consent is obtained.
          # consent_mode: 'auto'

          ## This value controls the duration a consent on this client remains remembered when the consent mode is
          ## configured as 'auto' or 'pre-configured'.
          # pre_configured_consent_duration: '30 days'

          # require_pushed_authorization_requests: false
          # require_pkce: false
          # pkce_challenge_method: 'S256'

          # authorization_signed_response_key_id: ''
          # authorization_signed_response_alg: 'RS256'
          # authorization_encrypted_response_key_id: ''
          # authorization_encrypted_response_alg: 'none'
          # authorization_encrypted_response_enc: 'A128CBC-HS256'

          # id_token_signed_response_key_id: ''
          # id_token_signed_response_alg: 'RS256'
          # id_token_encrypted_response_key_id: ''
          # id_token_encrypted_response_alg: 'none'
          # id_token_encrypted_response_enc: 'A128CBC-HS256'

          # access_token_signed_response_key_id: ''
          # access_token_signed_response_alg: 'none'
          # access_token_encrypted_response_key_id: ''
          # access_token_encrypted_response_alg: 'none'
          # access_token_encrypted_response_enc: 'A128CBC-HS256'

          # userinfo_signed_response_key_id: ''
          # userinfo_signed_response_alg: 'none'
          # userinfo_encrypted_response_key_id: ''
          # userinfo_encrypted_response_alg: 'none'
          # userinfo_encrypted_response_enc: 'A128CBC-HS256'

          # introspection_signed_response_key_id: ''
          # introspection_signed_response_alg: 'none'
          # introspection_encrypted_response_key_id: ''
          # introspection_encrypted_response_alg: 'none'
          # introspection_encrypted_response_enc: 'A128CBC-HS256'

          # request_object_signing_alg: 'RS256'
          # request_object_encryption_alg: ''
          # request_object_encryption_enc: ''

          # token_endpoint_auth_method: 'client_secret_basic'
          # token_endpoint_auth_signing_alg: 'RS256'

          # revocation_endpoint_auth_method: 'client_secret_basic'
          # revocation_endpoint_auth_signing_alg: 'RS256'

          # introspection_endpoint_auth_method: 'client_secret_basic'
          # introspection_endpoint_auth_signing_alg: 'RS256'

          # pushed_authorization_request_endpoint_auth_method: 'client_secret_basic'
          # pushed_authorization_request_endpoint_auth_signing_alg: 'RS256'

secret:
  additionalSecrets:
    authelia-reset-jwt-hmac-key-secret:
      items:
        - key: key
          path: authelia-reset-jwt-hmac-key-secret
    authelia-duo-api-token-secret:
      items:
        - key: token
          path: authelia-duo-api-token-secret
    authelia-lldap-bind-account-password-secret:
      items:
        - key: password
          path: authelia-lldap-bind-account-password-secret
    authelia-cookie-session-encryption-key-secret:
      items:
        - key: key
          path: authelia-cookie-session-encryption-key-secret

    authelia-redis-password-secret:
      items:
        - key: password
          path: authelia-redis-password-secret
    authelia-postgresql-credentials-secret:
      items:
        - key: password
          path: authelia-postgresql-credentials-secret
    authelia-smtp-password-secret:
      items:
        - key: password
          path: authelia-smtp-password-secret


certificates:
  # -- Name of an existing Secret manifest to mount which contains trusted certificates.
  existingSecret: ''

  # -- Extra annotations for the Certificates Secret manifest.
  annotations: {}

  # -- Extra labels for the Certificates Secret manifest.
  labels: {}

  # -- List of secret name value pairs to include in this Secret manifest.
  values: []
  # values:
  # - name: 'Example_Com_Root_Certificate_Authority_B64.pem'
  #   secretValue: 'LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURYekNDQWtlZ0F3SUJBZ0lMQkFBQUFBQUJJVmhUQ0tJd0RRWUpLb1pJaHZjTkFRRUxCUUF3VERFZ01CNEcKQTFVRUN4TVhSMnh2WW1Gc1UybG5iaUJTYjI5MElFTkJJQzBnVWpNeEV6QVJCZ05WQkFvVENrZHNiMkpoYkZOcApaMjR4RXpBUkJnTlZCQU1UQ2tkc2IySmhiRk5wWjI0d0hoY05NRGt3TXpFNE1UQXdNREF3V2hjTk1qa3dNekU0Ck1UQXdNREF3V2pCTU1TQXdIZ1lEVlFRTEV4ZEhiRzlpWVd4VGFXZHVJRkp2YjNRZ1EwRWdMU0JTTXpFVE1CRUcKQTFVRUNoTUtSMnh2WW1Gc1UybG5iakVUTUJFR0ExVUVBeE1LUjJ4dlltRnNVMmxuYmpDQ0FTSXdEUVlKS29aSQpodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU13bGRwQjVCbmdpRnZYQWc3YUV5aWllL1FWMkVjV3RpSEw4ClJnSkR4N0tLblFSZkpNc3VTK0ZnZ2tiaFVxc01nVWR3Yk4xazBldjFMS01QZ2owTUs2NlgxN1lVaGhCNXV6c1QKZ0hlTUNPRkowbXBpTHg5ZStwWm8zNGtubFRpZkJ0Yyt5Y3NtV1ExejNyREk2U1lPZ3hYRzcxdUwwZ1JneWttbQpLUFpwTy9iTHlDaVI1WjJLWVZjM3JIUVUzSFRnT3U1eUx5NmMrOUM3di9VOUFPRUdNK2lDSzY1VHBqb1djNHpkClFRNGdPc0MwcDZIcHNrK1FMakpnNlZmTHVRU1NhR2psT0NaZ2RiS2ZkLytSRk8rdUlFbjhyVUFWU05FQ01XRVoKWHJpWDc2MTN0MlNhZXI5ZndSUHZtMkw3RFd6Z1ZHa1dxUVBhYnVtRGszRjJ4bW1GZ2hjQ0F3RUFBYU5DTUVBdwpEZ1lEVlIwUEFRSC9CQVFEQWdFR01BOEdBMVVkRXdFQi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZJL3dTMytvCkxrVWtyazFRK21PYWk5N2kzUnU4TUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFCTFFOdkFVS3IreUF6djk1WlUKUlVtN2xnQUpRYXl6RTRhR0tBY3p5bXZtZExtNkFDMnVwQXJUOWZIeEQ0cS9jMmRLZzhkRWUzamdyMjVzYndNcApqak01UmNPTzVMbFhiS3I4RXBic1U4WXQ1Q1JzdVpSais5eFRhR2RXUG9PNHp6VWh3OGxvL3M3YXdsT3F6SkNLCjZmQmRSb3lWM1hwWUtCb3ZIZDdOQURkQmorMUViZGRUS0pkKzgyY0VIaFhYaXBhMDA5NU1KNlJNRzNOemR2UVgKbWNJZmVnN2pMUWl0Q2h3cy96eXJWUTRQa1g0MjY4TlhTYjdoTGkxOFlJdkRRVkVUSTUzTzl6SnJsQUdvbWVjcwpNeDg2T3lYU2hrRE9PeXlHZU1saEx4UzY3dHRWYjkrRTdnVUpUYjBvMkhMTzAySlFaUjdya3BlRE1kbXp0Y3BICldEOWYKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ=='
  # - name: 'Example_Com_Root_Certificate_Authority.pem'
  #   value: |
  #     -----BEGIN CERTIFICATE-----
  #     MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
  #     A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
  #     Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
  #     MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
  #     A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
  #     hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
  #     RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
  #     gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
  #     KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
  #     QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
  #     XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
  #     DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
  #     LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
  #     RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
  #     jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
  #     6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
  #     mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
  #     Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
  #     WD9f
  #     -----END CERTIFICATE-----

persistence:
  # -- Enable the PersistentVolumeClaim features for Authelia.
  enabled: false

  # -- Extra annotations for the PersistentVolumeClaim related manifests.
  annotations: {}

  # -- Extra annotations for the PersistentVolumeClaim related manifests.
  labels: {}

  # -- Mounts the PersistentVolumeClaim in read-only mode.
  readOnly: false

  # -- Mounts specifically a subpath of the PersistentVolumeClaim.
  subPath: ''

  # -- Uses an expression to mount a subpath of the PersistentVolumeClaim.
  subPathExpr: ''

  # -- Sets the mount propagation value for the PersistentVolumeClaim.
  mountPropagation: ''

  # -- Mounts an existing PersistentVolumeClaim.
  existingClaim: ''
  # existingClaim: 'my-claim-name'

  # -- Uses the specified storageClass for the PersistentVolumeClaim.
  storageClass: ''

  # -- Persistent Volume Name. Useful if Persistent Volumes have been provisioned in advance and you want to use a
  # specific one.
  volumeName: ''

  # -- PersistentVolumeClaim access modes.
  accessModes:
    - 'ReadWriteOnce'

  # -- PersistentVolumeClaim volume size.
  size: '100Mi'

  selector: {}

  extraPersistentVolumeClaims:
    example:
      # -- Enable this extra PersistentVolumeClaim.
      enabled: false

      # -- Extra annotations for this PersistentVolumeClaim manifest.
      annotations: {}

      # -- Extra annotations for this PersistentVolumeClaim manifest.
      labels: {}

      # -- Mounts the PersistentVolumeClaim in read-only mode.
      readOnly: false

      # -- Mounts specifically a subpath of the PersistentVolumeClaim.
      subPath: ''

      # -- Uses an expression to mount a subpath of the PersistentVolumeClaim.
      subPathExpr: ''

      # -- Sets the mount propagation value for the PersistentVolumeClaim.
      mountPropagation: ''

      # -- Mounts an existing PersistentVolumeClaim.
      existingClaim: ''
      # existingClaim: 'my-claim-name'

      # -- Uses the specified storageClass for the PersistentVolumeClaim.
      storageClass: ''

      # -- Persistent Volume Name. Useful if Persistent Volumes have been provisioned in advance and you want to use a
      # specific one.
      volumeName: ''

      # -- PersistentVolumeClaim access modes.
      accessModes:
        - 'ReadWriteOnce'

      # -- PersistentVolumeClaim volume size.
      size: '100Mi'

      selector: {}

# -- Configure mariadb database subchart under this key.
# This will be deployed when storage.mysql.deploy is set to true
# Currently settings need to be manually copied from here to the storage.mysql section
# For more options and to see the @default please see [mariadb chart documentation](https://github.com/bitnami/charts/tree/main/bitnami/mariadb)
# @default -- `{}`
mariadb:
  architecture: 'standalone'

  auth:
    database: 'authelia'

    username: 'authelia'

    password: 'authelia'

    rootPassword: 'authelia'

  primary:
    resources: {}

    persistence:
      enabled: false

      size: '1Gi'

      storageClass: ''

# -- Configure postgresql database subchart under this key.
# This will be deployed when storage.postgres.deploy is set to true
# Currently settings need to be manually copied from here to the storage.postgres section
# For more options and to see the @default please see [postgresql chart documentation](https://github.com/bitnami/charts/tree/main/bitnami/postgresql)
# @default -- `{}`
postgresql:
  auth:
    postgresPassword: 'authelia'

    username: 'authelia'

    password: 'authelia'

    database: 'authelia'

  primary:
    persistence:
      enabled: false

      storageClass: ''

      size: '1Gi'

    resources: {}

# -- Configure redis database subchart under this key.
# This will be deployed when session.redis.deploy is set to true
# Currently settings need to be manually copied from here to the session.redis section
# For more options and to see the @default please see [redis chart documentation](https://github.com/bitnami/charts/tree/main/bitnami/redis)
# @default -- `{}`
redis:
  architecture: 'standalone'

  auth:
    enabled: false

    sentinel: true

    password: 'redis'

    existingSecret: ''

    existingSecretPasswordKey: ''

    usePasswordFiles: false

  master:
    resources: {}

    priorityClassName: ''

    persistence:
      enabled: false

      storageClass: ''

      accessModes:
        - 'ReadWriteOnce'

      size: '1Gi'

  replica:
    replicaCount: 3

    resources: {}

    priorityClassName: ''

    persistence:
      enabled: false

      storageClass: ''

      accessModes:
        - 'ReadWriteOnce'

      size: '1Gi'
